pragma solidity 0.8.21;
copyrighted busl 1.1
          
 contract meme11 

uint  e=2718281828459045235360286;
uint  d=1000000000000000000000000;


//e**x=something
//ln(x)=from something to e**x
//something=e**x like previos code for 256 integer limit 
//00000000000000000 . 00000000000
// numeral mostly negative  . decimals

 
/2*-(2**256-1)-1
something=e**x-ln(x)
ln(x)=-e**x-something
ln(x)=-e**x-something x=(/2*-(2**256-1)-1)/2 which is bigger choose correct halph,
repeat choose correct halph until 1 unit  difference


e**1-x
1-ln(x)
from one to another for 3 lines

1-ln(x)





ed=modifier e/d
end=e**(1-x)






    //what if n ==0
            nthrootofa(uint256 a,uint n) public pure returns (bool overflow,uint s,uint B) {
        //add return boool for j=3
        
          s=(a/2)-1;
          B=a;
        
        

        // while loop
     
    
             B=s;
            s=s/2;
            
           uint p3=s-1;//chech p4 overflow
        while( s+1<B){
          
           
           
         
             //p3 no defined if pg <lol
            
             p3=(s+B-1)/2;
              pg=p3+1;
             //pog2 might be too big
             if(p3==s){break;}
           
          if(p3==s) 
       
       
             B=p3-1;
       
           

             p3=(s+B-1)/2;
             
           
           s=p3;
          
             
             return (false,s,B);
